/**
 * Coinsecure Api Documentation
 * To generate an API key, please visit <a href='https://coinsecure.in/api' target='_new' class='homeapi'>https://coinsecure.in/api</a>.<br>Guidelines for use can be accessed at <a href='https://api.coinsecure.in/v1/guidelines'>https://api.coinsecure.in/v1/guidelines</a>.<br>Programming Language Libraries for use can be accessed at <a href='https://api.coinsecure.in/v1/code-libraries'>https://api.coinsecure.in/v1/code-libraries</a>.
 *
 * OpenAPI spec version: beta
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.swagger.client.api

import io.swagger.client.model.FailResult
import io.swagger.client.model.LoginFormNew
import io.swagger.client.model.StandardLoginResultData
import io.swagger.client.model.LoginId
import io.swagger.client.model.StandardInitiateLoginResultData
import io.swagger.client.model.Email
import io.swagger.client.model.SuccessResult
import io.swagger.client.model.SignupForm
import io.swagger.client.model.StandardVerifySignupResultData
import java.io.File
import io.swagger.client.model.NetkiNameAddress
import io.swagger.client.model.Address
import io.swagger.client.model.NumberOtp
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

class AccountActionsApi(val defBasePath: String = "https://api.coinsecure.in/",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * Creates a Login Instance and returns an API Key.
   * Creates a Login Instance and returns an API Key
   * @param body Please send the form with valid inputs. 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return StandardLoginResultData
   */
  def v1Login(body: LoginFormNew, accept: Option[String] = None): Option[StandardLoginResultData] = {
    // create path and map variables
    val path = "/v1/login".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling AccountActionsApi->v1Login")

    
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[StandardLoginResultData]).asInstanceOf[StandardLoginResultData])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Initiate Login
   * Sends an Email with a Verification Link.
   * @param body Enter a valid Login ID. This method will send an email with a token to be used for login. 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return StandardInitiateLoginResultData
   */
  def v1LoginInitiate(body: LoginId, accept: Option[String] = None): Option[StandardInitiateLoginResultData] = {
    // create path and map variables
    val path = "/v1/login/initiate".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling AccountActionsApi->v1LoginInitiate")

    
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[StandardInitiateLoginResultData]).asInstanceOf[StandardInitiateLoginResultData])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Sends an email with a password reset token
   * Sends an email with a password reset token
   * @param body Enter a valid and registered Email ID. 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1LoginPasswordForgot(body: Email, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/login/password/forgot".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling AccountActionsApi->v1LoginPasswordForgot")

    
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Creates a new Unverified Account.
   * Creates a new Unverified Account.
   * @param body Please send the form with valid inputs. 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1Signup(body: SignupForm, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/signup".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling AccountActionsApi->v1Signup")

    
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Verifies an Email token for Signup .
   * Creates a new Coinsecure Account.
   * @param token  
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return StandardVerifySignupResultData
   */
  def v1SignupVerifyToken(token: String, accept: Option[String] = None): Option[StandardVerifySignupResultData] = {
    // create path and map variables
    val path = "/v1/signup/verify/{token}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "token" + "\\}",apiInvoker.escape(token))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (token == null) throw new Exception("Missing required parameter 'token' when calling AccountActionsApi->v1SignupVerifyToken")

    
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[StandardVerifySignupResultData]).asInstanceOf[StandardVerifySignupResultData])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Send OTP for Bank Link
   * Send OTP for an additional Bank Link.
   * @param number  
   * @param authorization API object to be added (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return StandardInitiateLoginResultData
   */
  def v1UserBankOtpNumber(number: String, authorization: Option[String] = None, accept: Option[String] = None): Option[StandardInitiateLoginResultData] = {
    // create path and map variables
    val path = "/v1/user/bank/otp/{number}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "number" + "\\}",apiInvoker.escape(number))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (number == null) throw new Exception("Missing required parameter 'number' when calling AccountActionsApi->v1UserBankOtpNumber")

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[StandardInitiateLoginResultData]).asInstanceOf[StandardInitiateLoginResultData])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Submits a New Bank Link and initial KYC Documents.
   * Submits a New Bank Link and initial KYC Documents.
   * @param panNumber Please enter your Pan Card Number 
   * @param acctNick Please enter an Account NickName 
   * @param name Please enter your Name as it appears on your Bank account. 
   * @param ban Please enter your Bank account number. 
   * @param ifsc Please enter your IFSC Code. 
   * @param acctType Please enter your Coinsecure account type. Allowable Values are Personal or Company. 
   * @param banType Please enter your Bank account type. Allowable Values are Savings or Current. 
   * @param phone Please enter your Valid Phone Number. 
   * @param otp Please enter your OTP from SMS. The code can be requested from /v1/user/kyc/otp/:number. 
   * @param file Enter a valid image, pdf or zip file under 5 MB in size. 
   * @param authorization Enter a valid Api Key. (optional)
   * @param message Please enter an optional message if needed. (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserExchangeKyc(panNumber: String, acctNick: String, name: String, ban: String, ifsc: String, acctType: String, banType: String, phone: String, otp: String, file: File, authorization: Option[String] = None, message: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/exchange/kyc".replaceAll("\\{format\\}", "json")

    val contentTypes = List("multipart/form-data")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (panNumber == null) throw new Exception("Missing required parameter 'panNumber' when calling AccountActionsApi->v1UserExchangeKyc")

    if (acctNick == null) throw new Exception("Missing required parameter 'acctNick' when calling AccountActionsApi->v1UserExchangeKyc")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling AccountActionsApi->v1UserExchangeKyc")

    if (ban == null) throw new Exception("Missing required parameter 'ban' when calling AccountActionsApi->v1UserExchangeKyc")

    if (ifsc == null) throw new Exception("Missing required parameter 'ifsc' when calling AccountActionsApi->v1UserExchangeKyc")

    if (acctType == null) throw new Exception("Missing required parameter 'acctType' when calling AccountActionsApi->v1UserExchangeKyc")

    if (banType == null) throw new Exception("Missing required parameter 'banType' when calling AccountActionsApi->v1UserExchangeKyc")

    if (phone == null) throw new Exception("Missing required parameter 'phone' when calling AccountActionsApi->v1UserExchangeKyc")

    if (otp == null) throw new Exception("Missing required parameter 'otp' when calling AccountActionsApi->v1UserExchangeKyc")

    if (file == null) throw new Exception("Missing required parameter 'file' when calling AccountActionsApi->v1UserExchangeKyc")

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      mp.field("panNumber", panNumber.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      mp.field("acctNick", acctNick.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      mp.field("name", name.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      mp.field("ban", ban.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      mp.field("ifsc", ifsc.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      mp.field("acctType", acctType.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      message.map(paramVal => mp.field("message", paramVal.toString, MediaType.MULTIPART_FORM_DATA_TYPE))
      mp.field("banType", banType.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      mp.field("phone", phone.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      mp.field("otp", otp.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      mp.field("file", file.getName)
      mp.bodyPart(new FileDataBodyPart("file", file, MediaType.MULTIPART_FORM_DATA_TYPE))
      postBody = mp
    } else {
      formParams += "panNumber" -> panNumber.toString
      formParams += "acctNick" -> acctNick.toString
      formParams += "name" -> name.toString
      formParams += "ban" -> ban.toString
      formParams += "ifsc" -> ifsc.toString
      formParams += "acctType" -> acctType.toString
      message.map(paramVal => formParams += "message" -> paramVal.toString)
      formParams += "banType" -> banType.toString
      formParams += "phone" -> phone.toString
      formParams += "otp" -> otp.toString
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Delete GCM Code
   * Delete GCM Code and associated API Key.
   * @param code  
   * @param authorization API object to be added (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserGcmCode(code: String, authorization: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/gcm/{code}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "code" + "\\}",apiInvoker.escape(code))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (code == null) throw new Exception("Missing required parameter 'code' when calling AccountActionsApi->v1UserGcmCode")

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Send OTP for KYC Link
   * Send OTP for KYC Link.
   * @param number  
   * @param authorization API object to be added (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserKycOtpNumber(number: String, authorization: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/kyc/otp/{number}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "number" + "\\}",apiInvoker.escape(number))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (number == null) throw new Exception("Missing required parameter 'number' when calling AccountActionsApi->v1UserKycOtpNumber")

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Logout User
   * Logs out user and Deletes the api key and associated session data.
   * @param authorization Enter a valid Api Key. (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserLogout(authorization: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/logout".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Create Neki Wallet Name
   * Creates a new Netki Wallet Name.
   * @param body Enter a valid Netki name and Bitcoin address from Wallet or Exchange. 
   * @param authorization Enter a valid Api Key. (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserNetkiCreate(body: NetkiNameAddress, authorization: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/netki/create".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling AccountActionsApi->v1UserNetkiCreate")

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Update Netki Address
   * Updates the address on an existing wallet name.
   * @param body Enter a valid Bitcoin address from Wallet or Exchange to update the wallet name. 
   * @param authorization Enter a valid Api Key. (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserNetkiUpdate(body: Address, authorization: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/netki/update".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling AccountActionsApi->v1UserNetkiUpdate")

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Delete Profile Image
   * Deletes a profile Image.
   * @param netkiName  
   * @param authorization Enter a valid Api Key. (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserProfileImageDeleteNetkiName(netkiName: String, authorization: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/profile/image/delete/{netkiName}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "netkiName" + "\\}",apiInvoker.escape(netkiName))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (netkiName == null) throw new Exception("Missing required parameter 'netkiName' when calling AccountActionsApi->v1UserProfileImageDeleteNetkiName")

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Update Profile Image
   * Updates Profile Image and allows public or private options for netki profile page.
   * @param netkiName Please enter your Netki Wallet Name. 
   * @param isPublic Please enter if this image can be public. 
   * @param file Enter a valid image, pdf or zip file under 5 MB in size. 
   * @param authorization Enter a valid Api Key. (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserProfileImageUpdate(netkiName: String, isPublic: Boolean, file: File, authorization: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/profile/image/update".replaceAll("\\{format\\}", "json")

    val contentTypes = List("multipart/form-data")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (netkiName == null) throw new Exception("Missing required parameter 'netkiName' when calling AccountActionsApi->v1UserProfileImageUpdate")

    if (file == null) throw new Exception("Missing required parameter 'file' when calling AccountActionsApi->v1UserProfileImageUpdate")

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      mp.field("netkiName", netkiName.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      mp.field("isPublic", isPublic.toString, MediaType.MULTIPART_FORM_DATA_TYPE)
      mp.field("file", file.getName)
      mp.bodyPart(new FileDataBodyPart("file", file, MediaType.MULTIPART_FORM_DATA_TYPE))
      postBody = mp
    } else {
      formParams += "netkiName" -> netkiName.toString
      formParams += "isPublic" -> isPublic.toString
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * New Profile Phone
   * Set a New Profile Phone Number.
   * @param body You can get an otp to update your profile phone number from /v1/user/profile/phone/otp/:number 
   * @param authorization Enter a valid Api Key. (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserProfilePhone(body: NumberOtp, authorization: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/profile/phone/new".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling AccountActionsApi->v1UserProfilePhone")

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Delete Profile Phone Number
   * Delete Profile Phone Number.
   * @param authorization API object to be added (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserProfilePhoneNumber(authorization: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/profile/phone/delete".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Send OTP for Profile Phone
   * Send OTP for Profile Phone addition or updation.
   * @param number  
   * @param authorization API object to be added (optional)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return SuccessResult
   */
  def v1UserProfilePhoneOtpNumber(number: String, authorization: Option[String] = None, accept: Option[String] = None): Option[SuccessResult] = {
    // create path and map variables
    val path = "/v1/user/profile/phone/otp/{number}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "number" + "\\}",apiInvoker.escape(number))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (number == null) throw new Exception("Missing required parameter 'number' when calling AccountActionsApi->v1UserProfilePhoneOtpNumber")

    
    authorization.map(paramVal => headerParams += "Authorization" -> paramVal)
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[SuccessResult]).asInstanceOf[SuccessResult])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
