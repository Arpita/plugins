/**
 * Coinsecure Api Documentation
 * To generate an API key, please visit <a href='https://coinsecure.in/api' target='_new' class='homeapi'>https://coinsecure.in/api</a>.<br>Guidelines for use can be accessed at <a href='https://api.coinsecure.in/v1/guidelines'>https://api.coinsecure.in/v1/guidelines</a>.<br>Programming Language Libraries for use can be accessed at <a href='https://api.coinsecure.in/v1/code-libraries'>https://api.coinsecure.in/v1/code-libraries</a>.
 *
 * OpenAPI spec version: beta
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.swagger.client.api

import io.swagger.client.model.FiatBankDataResponse
import io.swagger.client.model.FailResult
import io.swagger.client.model.RateDataResponse
import io.swagger.client.model.FiatDepDataResponse
import io.swagger.client.model.FiatWithDataResponse
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

class ExchangeBankFiatDataApi(val defBasePath: String = "https://api.coinsecure.in/",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * Exchange Bitcoin Deposit Addresses
   * Gets a List of Users Exchange Bitcoin Addresses.
   * @param authorization API object to be added 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return FiatBankDataResponse
   */
  def v1UserExchangeBankFiatAccounts(authorization: String, accept: Option[String] = None): Option[FiatBankDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/accounts".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatAccounts")

    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[FiatBankDataResponse]).asInstanceOf[FiatBankDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Available Exchange Fiat Balance
   * Returns balance which is in Available for Trades. The response is in paisa.
   * @param authorization API object to be added 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return RateDataResponse
   */
  def v1UserExchangeBankFiatBalanceAvailable(authorization: String, accept: Option[String] = None): Option[RateDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/balance/total".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatBalanceAvailable")

    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[RateDataResponse]).asInstanceOf[RateDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * In Trade Coin Balance
   * Returns in-trade or pending fiat balance in paisa.
   * @param authorization API object to be added 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return RateDataResponse
   */
  def v1UserExchangeBankFiatBalancePending(authorization: String, accept: Option[String] = None): Option[RateDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/balance/pending".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatBalancePending")

    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[RateDataResponse]).asInstanceOf[RateDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Total Exchange Fiat Balance
   * Returns users total fiat balance in paisa. Pending + Available
   * @param authorization API object to be added 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return RateDataResponse
   */
  def v1UserExchangeBankFiatBalanceTotal(authorization: String, accept: Option[String] = None): Option[RateDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/balance/available".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatBalanceTotal")

    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[RateDataResponse]).asInstanceOf[RateDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Cancelled Exchange Fiat Deposits
   * Gets a List of Cancelled Exchange Fiat Deposits. The value and fees are in paisa.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return FiatDepDataResponse
   */
  def v1UserExchangeBankFiatDepositCancelled(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[FiatDepDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/deposit/cancelled".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatDepositCancelled")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[FiatDepDataResponse]).asInstanceOf[FiatDepDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Unverified Exchange Fiat Deposits
   * Gets a List of Unverified Exchange Fiat Deposits. The value and fees are in paisa.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return FiatDepDataResponse
   */
  def v1UserExchangeBankFiatDepositUnverified(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[FiatDepDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/deposit/unverified".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatDepositUnverified")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[FiatDepDataResponse]).asInstanceOf[FiatDepDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Verified Exchange Fiat Deposits
   * Gets a List of Verified Exchange Fiat Deposits. The value and fees are in paisa.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return FiatDepDataResponse
   */
  def v1UserExchangeBankFiatDepositVerified(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[FiatDepDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/deposit/verified".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatDepositVerified")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[FiatDepDataResponse]).asInstanceOf[FiatDepDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Cancelled Exchange Fiat Withdrawals
   * Gets a List of Cancelled Exchange Fiat Withdrawals. The fiat value is in paisa.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return FiatWithDataResponse
   */
  def v1UserExchangeBankFiatWithdrawCancelled(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[FiatWithDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/withdraw/cancelled".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatWithdrawCancelled")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[FiatWithDataResponse]).asInstanceOf[FiatWithDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Completed Exchange Fiat Withdrawals
   * Gets a List of Completed Exchange Fiat Withdrawals. The fiat value is in paisa.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return FiatWithDataResponse
   */
  def v1UserExchangeBankFiatWithdrawCompleted(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[FiatWithDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/withdraw/completed".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatWithdrawCompleted")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[FiatWithDataResponse]).asInstanceOf[FiatWithDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Unverified Exchange Fiat Withdrawals
   * Gets a List of Unverified Exchange Fiat Withdrawals. The fiat value is in paisa.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return FiatWithDataResponse
   */
  def v1UserExchangeBankFiatWithdrawUnverified(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[FiatWithDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/withdraw/unverified".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatWithdrawUnverified")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[FiatWithDataResponse]).asInstanceOf[FiatWithDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Verified Exchange Fiat Withdrawals
   * Gets a List of Verified Exchange Fiat Withdrawals. The fiat value is in paisa.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return FiatWithDataResponse
   */
  def v1UserExchangeBankFiatWithdrawVerified(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[FiatWithDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/fiat/withdraw/verified".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankFiatDataApi->v1UserExchangeBankFiatWithdrawVerified")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[FiatWithDataResponse]).asInstanceOf[FiatWithDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
