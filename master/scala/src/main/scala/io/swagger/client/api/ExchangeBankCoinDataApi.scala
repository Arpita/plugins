/**
 * Coinsecure Api Documentation
 * To generate an API key, please visit <a href='https://coinsecure.in/api' target='_new' class='homeapi'>https://coinsecure.in/api</a>.<br>Guidelines for use can be accessed at <a href='https://api.coinsecure.in/v1/guidelines'>https://api.coinsecure.in/v1/guidelines</a>.<br>Programming Language Libraries for use can be accessed at <a href='https://api.coinsecure.in/v1/code-libraries'>https://api.coinsecure.in/v1/code-libraries</a>.
 *
 * OpenAPI spec version: beta
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.swagger.client.api

import io.swagger.client.model.TradeAddressDataResponse
import io.swagger.client.model.FailResult
import io.swagger.client.model.VolDataResponse
import io.swagger.client.model.CoinDepDataResponse
import io.swagger.client.model.TradeCoinWithdrawDataResponse
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

class ExchangeBankCoinDataApi(val defBasePath: String = "https://api.coinsecure.in/",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * Exchange Coin Addresses
   * Gets a List of Users Exchange Bitcoin Deposit Addresses.
   * @param authorization API object to be added 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return TradeAddressDataResponse
   */
  def v1UserExchangeBankCoinAddresses(authorization: String, accept: Option[String] = None): Option[TradeAddressDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/addresses".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinAddresses")

    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TradeAddressDataResponse]).asInstanceOf[TradeAddressDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Available Exchange Coin Balance
   * Returns balance which is in Available for Trades. The response is in satoshis.
   * @param authorization API object to be added 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return VolDataResponse
   */
  def v1UserExchangeBankCoinBalanceAvailable(authorization: String, accept: Option[String] = None): Option[VolDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/balance/total".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinBalanceAvailable")

    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[VolDataResponse]).asInstanceOf[VolDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * In Trade Coin Balance
   * Returns in-trade or pending coin balance in satoshi.
   * @param authorization API object to be added 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return VolDataResponse
   */
  def v1UserExchangeBankCoinBalancePending(authorization: String, accept: Option[String] = None): Option[VolDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/balance/pending".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinBalancePending")

    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[VolDataResponse]).asInstanceOf[VolDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Total Exchange Coin Balance
   * Returns users total coin balance in satoshis. Pending + Available
   * @param authorization API object to be added 
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return VolDataResponse
   */
  def v1UserExchangeBankCoinBalanceTotal(authorization: String, accept: Option[String] = None): Option[VolDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/balance/available".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinBalanceTotal")

    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[VolDataResponse]).asInstanceOf[VolDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Cancelled Exchange Coin Deposits
   * Gets a List of Cancelled Exchange Coin Deposits. The value and fees are in paisa.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return CoinDepDataResponse
   */
  def v1UserExchangeBankCoinDepositCancelled(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[CoinDepDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/deposit/cancelled".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinDepositCancelled")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[CoinDepDataResponse]).asInstanceOf[CoinDepDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Unverified Exchange Coin Deposits
   * Gets a List of Unverified Exchange Coin Deposits. The value and fees are in paisa.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return CoinDepDataResponse
   */
  def v1UserExchangeBankCoinDepositUnverified(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[CoinDepDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/deposit/unverified".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinDepositUnverified")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[CoinDepDataResponse]).asInstanceOf[CoinDepDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Verified Exchange Coin Deposits
   * Gets a List of Verified Exchange Coin Deposits. The value and fees are in paisa.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return CoinDepDataResponse
   */
  def v1UserExchangeBankCoinDepositVerified(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[CoinDepDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/deposit/verified".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinDepositVerified")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[CoinDepDataResponse]).asInstanceOf[CoinDepDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Cancelled Exchange Coin Withdrawals
   * Gets a List of Cancelled Coin Withdrawals. The value and fees are in satoshis.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return TradeCoinWithdrawDataResponse
   */
  def v1UserExchangeBankCoinWithdrawCancelled(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[TradeCoinWithdrawDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/withdraw/cancelled".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinWithdrawCancelled")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TradeCoinWithdrawDataResponse]).asInstanceOf[TradeCoinWithdrawDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Completed Exchange Coin Withdrawals
   * Gets a List of Completed Coin Withdrawals. The value and fees are in satoshis.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return TradeCoinWithdrawDataResponse
   */
  def v1UserExchangeBankCoinWithdrawCompleted(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[TradeCoinWithdrawDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/withdraw/completed".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinWithdrawCompleted")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TradeCoinWithdrawDataResponse]).asInstanceOf[TradeCoinWithdrawDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Unverified Exchange Coin Withdrawals
   * Gets a List of Unverified Exchange Coin Withdrawals. The value and fees are in satoshis.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return TradeCoinWithdrawDataResponse
   */
  def v1UserExchangeBankCoinWithdrawUnverified(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[TradeCoinWithdrawDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/withdraw/unverified".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinWithdrawUnverified")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TradeCoinWithdrawDataResponse]).asInstanceOf[TradeCoinWithdrawDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Verified Exchange Coin Withdrawals
   * Gets a List of Verified Exchange Coin Withdrawals. The value and fees are in satoshis.
   * @param authorization API object to be added 
   * @param from From date in Epoch, defaults to 0 if invalid input or greater than current time. (Optional) (optional, default to 0)
   * @param to To Date in Epoch, defaults to current time if invalid input or greater than current time. (Optional) (optional, default to 9223372036854776000)
   * @param max Max defaults to 10 if invalid input and defaults to 100 if greater than 100. (Optional) (optional, default to 10)
   * @param offset Offset defaults to 0 if input is invalid. (Optional) (optional, default to 0)
   * @param accept JSON, XML or CSV can be returned (Optional) (optional)
   * @return TradeCoinWithdrawDataResponse
   */
  def v1UserExchangeBankCoinWithdrawVerified(authorization: String, from: Option[Long] /* = 0*/, to: Option[Long] /* = 9223372036854776000*/, max: Option[Integer] /* = 10*/, offset: Option[Long] /* = 0*/, accept: Option[String] = None): Option[TradeCoinWithdrawDataResponse] = {
    // create path and map variables
    val path = "/v1/user/exchange/bank/coin/withdraw/verified".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (authorization == null) throw new Exception("Missing required parameter 'authorization' when calling ExchangeBankCoinDataApi->v1UserExchangeBankCoinWithdrawVerified")

    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    to.map(paramVal => queryParams += "to" -> paramVal.toString)
    max.map(paramVal => queryParams += "max" -> paramVal.toString)
    offset.map(paramVal => queryParams += "offset" -> paramVal.toString)
    
    headerParams += "Authorization" -> authorization
    accept.map(paramVal => headerParams += "accept" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TradeCoinWithdrawDataResponse]).asInstanceOf[TradeCoinWithdrawDataResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
